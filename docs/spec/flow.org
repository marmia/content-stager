* URL投入 → S1 → S2 の処理フロー（MVP）

このドキュメントは、S1/S2を「なぜ分けるのか」「どの段階でTopic分割が走るのか」を、
手動実行（ユーザー起動）前提で具体化する。

** 先に結論

- Topic分割は「本文取得が成功した後」に実施する。
- S1は「未処理/失敗/やり直し可能な入口の滞留」、S2は「最小構造化が終わって不可視で寝かせる滞留」。
- ユーザーが手動で処理を走らせた結果、同一セッション内でS1→S2まで一気に進むことは普通に起きる。
  - ただし、失敗時やTopic抽出スキップ時に留まる場所としてS1は必要。

** なぜS1/S2を分けるのか（MVP観点）

- 失敗の吸収:
  - 本文が取得できない/本文が不完全で意味をなさない、などを「S1に留める」で扱える
- 再実行の前提:
  - 同一URLの再取得を別Contentとして追加する（decisions.org）ため、失敗も含めて履歴を残す必要がある
- 可視性の設計:
  - S2は「棚として存在だけ匂わせる」ための層で、本文の一覧表示をしない
  - 入口（S1）で“見える/見えない”を混同すると、ガードレールが崩れやすい

** ユーザー操作と処理の対応（MVP）

*** 操作1: URLを投入してS2まで処理する（手動・1 Skill）

- 入力: `url`
- 複数URLの場合: 1行1URLのファイル入力
- UIインタラクション: なし（保存確認/エラー表示はあり得る）
- 想定Skill: `ingest_url`
- 処理（概念上のステップ分解）:
  - Step 0: `Content` を作成し `state='S1'` で保存する

- Step A: 本文取得（Fetch）
  - provider: MVPでは `agent-browser` 固定
  - 成果物:
    - `fetch_runs` に `article_text`（スナップショット）とハッシュ等を保存
    - 失敗時は `error_summary` を保存し、`Content` はS1に留める

- Step B: 検出（Detect Issues）
  - 形式破綻チェック（文脈欠落／リンク切れ／完全重複）
  - 強シグナル検出（期限/依存/不可逆/安全）は「フラグ付与のみ」
  - いずれも「状態遷移のトリガーにしない」（concepts.orgの拘束）
  - 補足:
    - 本文が「意味をなすかどうか」の判定（短すぎる/断片のみ等）はここで行い、
      不可の場合はTopic抽出をスキップしてS1に留める

- Step C: Topic分割（Extract Topics）
  - 前提: Fetchが成功し `article_text` が得られている
  - 成果物:
    - `topic_runs` と `topics` を作る

- Step D: 状態更新（Transition）
  - Topic等の最小構造が得られたら `state='S2'` に更新する
  - それ以外（Fetch失敗/Topic抽出スキップ等）は `state='S1'` のまま

*** 操作2: （任意）Topicに意図ラベルを付ける

- decisions.orgの通り、意図ラベルはTopicに付与する
- 付与は別Skill（例: `label_topics`）で行う想定（UIの作り込みはMVPでは必須にしない）

*** 操作3: （任意）棚の匂わせを見る（S2の観測窓）
- S2のContentを直接一覧で見ない
- Shelf/Topicの集約情報だけを提示する（詳細は別ドキュメントで確定）

** 補足: 「自動的にS2まで進むのでは？」について

運用として「URLを入れた直後に処理（1 Skill）を実行する」なら、結果として同じセッションでS2まで進む。
それでもS1は、以下の理由で残す価値がある。

- 失敗時の停留と再実行の基点になる
- 「入力」と「構造化」を分離でき、判断疲れを避ける設計思想に合う
- 将来、入力だけ溜めて後でまとめて処理する運用にも自然に拡張できる
